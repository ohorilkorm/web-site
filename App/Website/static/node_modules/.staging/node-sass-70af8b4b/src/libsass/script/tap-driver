#!/usr/bin/env sh
# Copyright (C) 2011-2013 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that program.

# This file is maintained in Automake, please report
# bugs to <bug-automake@gnu.org> or send patches to
# <automake-patches@gnu.org>.

scriptversion=2011-12-27.17; # UTC

# Make unconditional expansion of undefined variables an error.  This
# helps a lot in preventing typo-related bugs.
set -u

me=tap-driver.sh

fatal ()
{
  echo "$me: fatal: $*" >&2
  exit 1
}

usage_error ()
{
  echo "$me: $*" >&2
  print_usage >&2
  exit 2
}

print_usage ()
{
  cat <<END
Usage:
  tap-driver.sh --test-name=NAME --log-file=PATH --trs-file=PATH
                [--expect-failure={yes|no}] [--color-tests={yes|no}]
                [--enable-hard-errors={yes|no}] [--ignore-exit]
                [--diagnostic-string=STRING] [--merge|--no-merge]
                [--comments|--no-comments] [--] TEST-COMMAND
The \`--test-name', \`--log-file' and \`--trs-file' options are mandatory.
END
}

# TODO: better error handling in option parsing (in particular, ensure
# TODO: $log_file, $trs_file and $test_name are defined).
test_name= # Used for reporting.
log_file=  # Where to save the result and output of the test script.
trs_file=  # Where to save the metadata of the test run.
expect_failure=0
color_tests=0
merge=0
ignore_exit=0
comments=0
diag_string='#'
while test $# -gt 0; do
  case $1 in
  --help) print_usage; exit $?;;
  --version) echo "$me $scriptversion"; exit $?;;
  --test-name) test_name=$2; shift;;
  --log-file) log_file=$2; shift;;
  --trs-file) trs_file=$2; shift;;
  --color-tests) color_tests=$2; shift;;
  --expect-failure) expect_failure=$2; shift;;
  --enable-hard-errors) shift;; # No-op.
  --merge) merge=1;;
  --no-merge) merge=0;;
  --ignore-exit) ignore_exit=1;;
  --comments) comments=1;;
  --no-comments) comments=0;;
  --diagnostic-string) diag_string=$2; shift;;
  --) shift; break;;
  -*) usage_error "invalid option: '$1'";;
  esac
  shift
done

test $# -gt 0 || usage_error "missing test command"

case $expect_failure in
  yes) expect_failure=1;;
    *) expect_failure=0;;
esac

if test $color_tests = yes; then
  init_colors='
    color_map["red"]="[0;31m" # Red.
    color_map["grn"]="[0;32m" # Green.
    color_map["lgn"]="[1;32m" # Light green.
    color_map["blu"]="[1;34m" # Blue.
    color_map["mgn"]="[0;35m" # Magenta.
    color_map["std"]="[m"     # No color.
    color_for_result["ERROR"] = "mgn"
    color_for_result["PASS"]  = "grn"
    color_for_result["XPASS"] = "red"
    color_for_result["FAIL"]  = "red"
    color_for_result["XFAIL"] = "lgn"
    color_for_result["SKIP"]  = "blu"'
else
  init_colors=''
fi

# :; is there to work around a bug in bash 3.2 (and earlier) which
# does not always set '$?' properly on redirection failure.
# See the Autoconf manual for more details.
:;{
  (
    # Ignore common signals (in this subshell only!), to avoid potential
    # problems with Korn shells.  Some Korn shells are known to propagate
    # to themselves signals that have killed a child process they were
    # waiting for; this is done at least for SIGINT (and usually only for
    # it, in truth).  Without the `trap' below, such a behaviour could
    # cause a premature exit in the current subshell, e.g., in case the
    # test command it runs gets terminated by a SIGINT.  Thus, the awk
    # script we are piping into would never seen the exit status it
    # expects on its last input line (which is displayed below by the
    # last `echo $?' statement), and would thus die reporting an internal
    # error.
    # For more information, see the Autoconf manual and the threads:
    # <http://lists.gnu.org/archive/html/bug-autoconf/2011-09/msg00004.html>
    # <http://mail.opensolaris.org/pipermail/ksh93-integration-discuss/2009-February/004121.html>
    trap : 1 3 2 13 15
    if test $merge -gt 0; then
      exec 2>&1
    else
      exec 2>&3
    fi
    "$@"
    echo $?
  ) | LC_ALL=C ${AM_TAP_AWK-awk} \
        -v me="$me" \
        -v test_script_name="$test_name" \
        -v log_file="$log_file" \
        -v trs_file="$trs_file" \
        -v expect_failure="$expect_failure" \
        -v merge="$merge" \
        -v ignore_exit="$ignore_exit" \
        -v comments="$comments" \
        -v diag_string="$diag_string" \
'
# FIXME: the usages of "cat >&3" below could be optimized when using
# FIXME: GNU awk, and/on on systems that supports /dev/fd/.

# Implementation note: in what follows, `result_obj` will be an
# associative array that (partly) simulates a TAP result object
# from the `TAP::Parser` perl module.

## ----------- ##
##  FUNCTIONS  ##
## ----------- ##

function fatal(msg)
{
  print me ": " msg | "cat >&2"
  exit 1
}

function abort(where)
{
  fatal("internal error " where)
}

# Convert a boolean to a "yes"/"no" string.
function yn(bool)
{
  return bool ? "yes" : "no";
}

function add_test_result(result)
{
  if (!test_results_index)
    test_results_index = 0
  test_results_list[test_results_index] = result
  test_results_index += 1
  test_results_seen[result] = 1;
}

# Whether the test script should be re-run by "make recheck".
function must_recheck()
{
  for (k in test_results_seen)
    if (k != "XFAIL" && k != "PASS" && k != "SKIP")
      return 1
  return 0
}

# Whether the content of the log file associated to this test should
# be copied into the "global" test-suite.log.
function copy_in_global_log()
{
  for (k in test_results_seen)
    if (k != "PASS")
      return 1
  return 0
}

# FIXME: this can certainly be improved ...
function get_global_test_result()
{
    if ("ERROR" in test_results_seen)
      return "ERROR"
    if ("FAIL" in test_results_seen || "XPASS" in test_results_seen)
      return "FAIL"
    all_skipped = 1
    for (k in test_results_seen)
      if (k != "SKIP")
        all_skipped = 0
    if (all_skipped)
      return "SKIP"
    return "PASS";
}

function stringify_result_obj(result_obj)
{
  if (result_obj["is_unplanned"] || result_obj["number"] != testno)
    return "ERROR"

  if (plan_seen == LATE_PLAN)
    return "ERROR"

  if (result_obj["directive"] == "TODO")
    return result_obj["is_ok"] ? "XPASS" : "XFAIL"

  if (result_obj["directive"] == "SKIP")
    return result_obj["is_ok"] ? "SKIP" : COOKED_FAIL;

  if (length(result_obj["directive"]))
      abort("in function stringify_result_obj()")

  return result_obj["is_ok"] ? COOKED_PASS : COOKED_FAIL
}

function decorate_result(result)
{
  color_name = color_for_result[result]
  if (color_name)
    return color_map[color_name] "" result "" color_map["std"]
  # If we are not using colorized output, or if we do not know how
  # to colorize the given result, we should return it unchanged.
  return result
}

function report(result, details)
{
  if (result ~ /^(X?(PASS|FAIL)|SKIP|ERROR)/)
    {
      msg = ": " test_script_name
      add_test_result(result)
    }
  else if (result == "#")
    {
      msg = " " test_script_name ":"
    }
  else
    {
      abort("in function report()")
    }
  if (length(details))
    msg = msg " " details
  # Output on console might be colorized.
  print decorate_result(result) msg
  # Log the result in the log file too, to help debugging (this is
  # especially true when said result is a TAP error or "Bail out!").
  print result msg | "cat >&3";
}

function testsuite_error(